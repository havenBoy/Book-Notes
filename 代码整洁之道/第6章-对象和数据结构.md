# 第 6 章 对象和数据结构 87-94
　　将变量设置为私有（private）有一个理由：我们不想其他人依赖这些变量。

## 6.1 数据抽象
　　隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！类并不简单地用取值器和赋值器将其变量推向外间，而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据本体。
　　我们不愿暴露数据细节，更愿意以抽象形态表述数据，这并不只是用接口和 / 或赋值器、取值器就万事大吉。要以最好的方式呈现某个对象包含的数据，需要做严肃的思考。傻乐着乱加取值器和赋值器，是最坏的选择。

## 6.2 数据、对象的反对称性
　　对象把数据隐藏于抽象之后，曝露操作数据的函数。数据结构曝露其数据，没有提供有意义的函数。他们是对立的。这种差异貌似微小，但却有深远的含义。
　　过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。反过来讲也说得通：过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。所以，对于面向对象较难的事，对于过程式代码却较容易，反之亦然。
　　在任何一个复杂系统中，都会有需要添加新数据类型而不是新函数的时候。这时，对象和面向对象就比较合适。另一方面，也会有想要添加新函数而不是数据类型的时候。在这种情况下，过程式代码和数据结构更合适。

## 6.3 得墨忒耳律
　　著名的得墨忒耳律（The Law of Demeter）认为，模块不应了解它所操作对象的内部情形。对象隐藏数据，曝露操作。这意味着对象不应通过存取器曝露其内部结构，因为这样更像是曝露而非隐藏其内部结构。
　　更准确地说，得墨忒耳律认为，类 C 的方法 f 只应该调用以下对象的方法：
  * C
  * 由 f 创建的对象；
  * 作为参数传递给 f 的对象；
  * 由 C 的实体变量持有的对象。
  方法不应调用由任何函数返回的对象的方法。








