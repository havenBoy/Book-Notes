### JVM管理
> java中不会显式的调用分配内存的函数，因为分配内存与内存的销毁都由jvm自动完成，出现内存泄漏的几率较低，但有必要去了解jvm是如何管理内存的，这样在出现内存泄漏时能够迅速的定位到问题所在；

* 8.1 物理内存与虚拟内存
  - 物理内存指的是RAM（随机存储器），与之对应的是寄存器，用于存储计算单元执行指令的中间结果，决定一次计算可以使用的最大数值
  - 连接处理器与RAM是地址总线，宽度影响物理地址的索引范围，32位总线宽度可以有4Gb的内存空间
  - 在运行程序时需要向操作系统申请内存地址，进程直接是相互独立的，每个进程只能访问自己的内存空间，这里所谓的独立是指逻辑独立
  - 虚拟内存出现使得多个进程可以同时运行共享物理内存，还可以扩展地址空间
  - 一个进程在不活动的情况下，操作系统会把物理内存上的数据移到磁盘文件中，从而使得物理内存留给正在活动的程序使用，如果要重新唤醒一个很长时间没有使用的程序时，会把磁盘上的数据重新交给物理内存，这个交换需要尽可能的避免，系统会变得缓慢
* 8.2 内核空间和用户空间
  - 一般来说操作系统会把内存空间氛围内核空间和用户空间，程序只能使用用户空间
  - 内核空间指操作系统运行时所使用的用于程序调度，连接资源硬件的等程序逻辑
  - 空间的划分：为了保证操作系统的安全性与稳定性，用户程序是不能访问操作系统的内存空间，例如硬件的资源只能由操作系统来发起，当用户需要访问硬件资源时，需要系统调用，每一次的系统调用会存在2个空间的切换
  - 空间大小的划分：首先需要保证内核有足够的空间来运行
* 8.3 java中那些组件需要使用内存
  - java堆 用于存储java对象的内存区域  堆的大小在JVM启动时确定，由-Xms 与 -Xmx 分别代表最小与最大，堆的大小一旦确定，就不可再向操作系统再次申请，同时空闲时也不可再次利用 
  - 线程  JVM实际运行的实体   如果处理的线程数大于当前系统的处理器数量，那么效率会比较低
  - 类与类加载器  称为永久代  JVM会按需加载的，不会把一个jar包的所有类全部加载
  - NIO
    * 引入一种基于通道与缓冲区来执行I/O的新方式，分配内存时本机内存而不是java堆内存，每次分配都会系统调用
    * 如果产生的数据只是在操作系统的内核中，那么不需要把数据复制在Java内存中，效率也较高
  - JNI 
    * 使得本机程序可以调用java方法，也就是native memory，实际上本身的java应用会调用类库功能 例如文件操作，网络I/O
    * 会增加java运行时本机内存占用
* 8.4 JVM内存结构
  - PC寄存器 ： 保存当前正常执行程序的内存地址，对于native方法没有必须记录记录执行的指针位置
  - java栈 ： 每创建一个线程就会创建一个java栈，栈中会有多个栈帧，栈帧与每个方法关联起来，包括参数，以及方法返回值信息
  - 堆： 存储java对象，是被所有java线程共享的，所以需要注意到同步的问题
  - 方法区 : 存储类结构信息的地方，
  - 运行时常量池： 
  - 本地方法栈: 为JVM 运行Native方法准备的空间，许多的Native方法都是由C实现的
* JVM内存分配策略
  - 8.5.1 通常的内存分配策略
    * 静态内存分配  程序编译时确定每个数据在运行时的存储空间需求
    * 栈内存分配  动态分配策略 
    * 堆内存分配