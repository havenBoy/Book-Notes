### 14.类型信息

> 运行时类型信息可以使得在程序运行时发现和使用类型信息，一种是传统的，在编译时知道对象的类型，另外一种是反射机制

* 14.1 为什么需要RTTI
  - 大多数代码尽可能的少的了解对象的具体类型，，而是与对象家族中的一个统用表示,使用URI标记了一个网络的资源，统一资源标志符，，使得代码更加的方便维护，所以多态是对象编程的基本目标
* 14.2 Class对象
  - 类是程序的一部分，，每个类都有一个Class对象，运行这个程序的java虚拟机将成为类加载器的子系统
  - 所有的类都是在第一次使用的时候动态加载在JVm中，当程序创建一个对类的静态成员的引用时，会加载，关键字new
  - 各个部分是在真正需要加载时才会被加载
  - 类加载器会首先判断这个类是否已经被加载，之后会加载这类的所有对象
  - static初始化是在类加载时进行的，Class.ForName()是Class对象的一个static方法
* 14.3 类型转换前先做检查
  - 传统类型的转换，由RTTI确保转换的正确性，如果执行一个错误的类型转换，会抛出一个ClassCastException
  - 代表对象的类型的Class对象，通过查询Class对象获取运行时所需要的类型
  - 关键字instanceof ,返回一个布尔值，告诉我们对象是不是某个特定类型的实例，目的是在向下转型时的提问
  - 
* 14.4 注册工厂
  - 生成
* 14.5 instanceof与Class的等价性
  - 二者具有一个重要的区别：前者保持了类型的概念，而后者比较的是Class对象，没有考虑继承的因素在里边
* 14.6 反射：运行时的类信息
  - 如果你可以回去一个指向并不存在于你程序空间中的对象的引用，如何使用这种类的引用？
  - java.lang.reflect类库对反射的概念进行支持，该类包括了Field，Method以及Constructor类
  - 使用get和set方法获取和修改与Field对象关联的字段，使用invoke方法调用Method对象关联的方法
  - 14.6.1 类方法提取器
    * 
* 14.7 动态代理
  - 代理是基本的设计模式之一，使用插入的用来替代实际对象的对象，代理通常充当着中间人的角色
  - java的动态代理可以动态的创建代理并动态的处理对所代理的方法的调用
* 14.8 空对象
  - 
* 14.9 接口与类型信息
  - 接口的关键目的是降低耦合性，为了使得程序的耦合度达到你的期望，可以直接申明实现使用包的访问权限，这样在包的外部看不见
  - 
* 总结
  - RTTI允许通过匿名类的引用来发现类型信息，建议是凡是可以使用多态地方使用多态，只是在必要的时候进行使用RTTI
  - 在设计时，为了某个类的利益会把某个特性放在基类中，意味者从这个基类派生出的所有的其他子类都带有这些没有意义的东西
  - 解决的办法是把这些方法放在一个某个合适的类中，是由RTTI提供，也可以把某个方法中置于基类中；
  - RTTI也涉及了解决效率的问题，有可能是使用了多态，但失去了程序的高效性，首先要让程序运行起来，其次考虑他的速度
  - 反射允许更加动态的编程风格