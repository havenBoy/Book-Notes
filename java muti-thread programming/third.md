### 线程间的通信 - 3

#### 3.1 wait/notify

* wait
  - wait使得当前运行的线程进行等待，是object方法，直到被通知或者中断
  - wait在调用前需要获取对象锁，故需要在同步的方法中才可以调用，如果没有持有调用适当的锁，会抛出异常
* notify
  - 同样需要获取对象锁在同步代码块中才可调用，如果没有持有适当的锁也会抛出异常 且是runtimeException
  - 作用是唤醒被wait方法作用的线程，由原来的阻塞状态变成运行状态，但只是“一个”
  - notifyAll会唤醒所有阻塞的线程，唤醒后优先级别高的先运行，取决于JVM的决定



#### 3.2 方法join的使用

* 3.2.1 学习之前的铺垫
  - 如果主线程想等待子线程执行完成后再次执行使用join，作用是等待线程对象的销毁
  - 作用是使所属的线程对象正常执行run方法中的任务，而使得当前线程进行无限期的阻塞
  - 具有使线程排队运行的作用
  - join(long) 是可以设置等待的时间  与sleep(long) 区别在于，join内部使用wait(long)实现，具有释放锁的功能
  - 

#### 3.3 类ThreadLocal的使用
> 实现每一个线程都有自己的共享变量，是一个全局存放数据的盒子
  - 第一次调用get方法时返回的值是null，通过之后的set方法进行值的设置
  - 解决了不同线程间的隔离性，不同线程拥有自己的值
  - 解决第一次get返回null的问题   覆盖initValue()方法，返回值即为初始化的值