# 第14章 多线程 620-702
	本章内容：
	* 什么是线程
	* 中断线程
	* 线程状态
	* 线程属性
	* 同步
	* 阻塞队列
	* 线程安全的集合
	* Collable与Future
	* 执行器
	* 同步器
	* 线程与Swing

1. 通常，每一个任务称为一个线程（thread），它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序（multithreaded）。
2. 多进程与多线程有哪些区别呢？本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。

## 14.1 什么是线程
1. Thread类的静态sleep方法将暂停给定的毫秒数。调用Thread.sleep不会创建一个新线程，sleep是Thread类的静态方法，用于暂停当前线程的活动。sleep方法可以抛出一个InterruptedException异常。
2. java.lang.Thread 1.0
	* static void sleep(long millis)
	休眠给定的毫秒数。
	参数：millis 休眠的毫秒数
3. 不要调用Thread类或Runnable对象的run方法。直接调用run方法，只会执行同一个线程中的任务，并不会启动新线程。应该调用Thread.start方法。这个方法将创建一个执行run方法的新线程。
4. java.lang.Thread 1.0
	* Thread(Runnable target)
	构造一个新线程，用于调用给定target的run()方法。
	* void start()
	启动这个线程，将引发调用run()方法。这个方法将立即返回，并且新线程将并行运行。
	* void run()
	调用关联Runnable的run方法。
5. java.lang.Runnable 1.0
	* void run()
	必须覆盖这个方法，并在这个方法中提供所要执行的任务指令。

## 14.2 中断线程
1. 当线程的run方法执行方法体重最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。在Java的早期版本中，还有一个stop方法，其他线程可以调用它终止线程。但是，这个方法现在已经被弃用了。
2. 有一种可以强制线程终止的方法。然而，interrupt方法可以用来请求终止线程。
3. 当对一个线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。
4. 调用Thread.currentThread().isInterrputed()方法获得当前线程的中断状态是否被置位。但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个被阻塞的线程（调用sleep或wait）上调用interrupt方法时，阻塞调用将会被Interrupt Exception异常中断（存在不能被中断的阻塞I/O调用，应该考虑选择可中断的调用）。
5. 没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普通的情况是，线程将简单地将中断作为一个终止的请求。
6. 如果在每次工作迭代之后都调用sleep方法（或者其他的可中断方法），isInterrpted检测既没有必要也没有用处。如果在种蒜状态被置位时调用sleep方法，它不会休眠。相反，它将清除这一状态（！）并抛出InterrputedException。因此，如果你的循环调用sleep，不会检测中断状态，相反，需要捕获InterrputedException异常。
7. 有两个非常类似的方法，interrupted和isInterrupted。Interrupted方法是一个静态方法，它检测当前的线程是否被中断。而且，调用interrupted方法会清除该线程的中断状态。另一方面，isInterrupted方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。
8. java.lang.Thread 1.0
	* void interrupt()
	向线程发送中断请求。线程的中断状态将设置为true。如果目前该线程被一个sleep调用阻塞，那么，InterruptedException异常被抛出。
	* static boolean interrupted()
	测试当前线程（即正在执行这一命令的线程）是否被中断。注意，这是一个静态方法。这一调用会产生副作用-它将当前线程的中断状态重置为false。
	* boolean isInterrupted()
	测试线程是否被终止。不像静态的中断方法，这一调用不改变线程的中断状态。
	* static Thread currentThread()
	返回代表当前执行线程的Thread对象。

## 14.3 线程状态
1. 线程可以有如下6种状态：
	* New(新创建)
	* Runnable(可运行)
	* Blocked(被阻塞)
	* Waiting(等待)
	* Timed waiting(计时等待)
	* Terminated(被终止)

#### 14.3.1 新创建线程
1. 当用new操作符创建一个新线程，如new Thread(r)，该线程还没有开始运行。这意味着它的状态是new。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基本工作要做。

#### 14.3.2 可运行线程
1. 一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。（Java的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态。）
2. 一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。
3. 在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行）。

#### 14.3.3 被阻塞线程和等待线程
1. 当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。
	* 当一个线程试图获取一个内部的对象锁（而不是java.util.concurrect库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
	* 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。实际上，被阻塞状态与等待状态是由很大不同的。
	* 有几个方法有一个超时参数。调用它们导致线程进入计时等待（timed waiting）状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep和Object.wait、Thread.join、Lock.tryLock以及Condition.awit的计时版。
2. 当一个线程被阻塞或等待时（或终止时），另一个线程被调度为运行状态。当一个线程被重新激活（例如，因为超时期满或成功地获得一个锁），调度器检查它是否具有比当前运行线程更高的优先级。如果是这样，调度器从当前运行线程中挑选一个，剥夺其运行权，选择一个新的线程运行。
3. 线程状态图
![]()

#### 14.3.4 被终止的线程
1. 线程因如下两个原因之一而被终止：
	* 因为run方法正常退出而自然死亡。
	* 因为一个没有捕获的异常终止了run方法而意外死亡。

特别是，可以调用线程的stop方法杀死一个线程。该方法抛出ThreadDeath错误对象，由此杀死线程。但是，stop方法已过时，不要在自己的代码中调用这个方法。
2. java.lang.Thread 1.0
	* void join()
	等待终止指定的线程。
    * void join(long millis)
    等待指定的线程死亡或者经过指定的毫秒数。
    * Thread.State getState() 5.0
    得到这一线程的状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING或TERMINATED之一。
    * void stop()
    停止该线程。这一方法已过时。
    * void suspend()
    暂停这一线程的执行。这一方法已过时。
    * void resume()
    恢复线程。这一方法仅仅在调用suspend()之后调用。这一方法已过时。

## 14.4 线程属性
1. 线程的各种属性，其中包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。

#### 14.4.1 线程优先级
1. 在Java程序设计语言中，每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。可以用setPriority方法提高或降低任何一个线程的优先级。可以将优先级设置为在MIN_PRIORITY(在Thread类中定义为1)与MAX_PRIORITY(定义为10)之间的任何值。NORM_PRIORITY被定义为5。
2. 
3. 

#### 14.4.2 守护线程
1. 
2. 
3. 

#### 14.4.3 未捕获异常处理器
1. 
2. 
3. 

## 14.5 同步
1. 
2. 
3. 

#### 14.5.1 竞争条件的一个例子
1. 
2. 
3. 

#### 14.5.2 竞争条件详解
1. 
2. 
3. 

#### 14.5.3 锁对象
1. 
2. 
3. 

#### 14.5.4 条件对象
1. 
2. 
3. 

#### 14.5.5 synchronized关键字
1. 
2. 
3. 

#### 14.5.6 同步阻塞
1. 
2. 
3. 

#### 14.5.7 监视器概念
1. 
2. 
3. 

#### 14.5.8 Volatile域
1. 
2. 
3. 

#### 14.5.9 final变量
1. 
2. 
3. 

#### 14.5.10 原子性
1. 
2. 
3. 

#### 14.5.11 死锁
1. 
2. 
3. 

#### 14.5.12 线程局部变量
1. 
2. 
3. 

#### 14.5.13 锁测试与超时
1. 
2. 
3. 

#### 14.5.14 读/写锁
1. 
2. 
3. 

#### 14.5.15 为什么弃用stop和suspend方法
1. 
2. 
3. 

## 14.6 阻塞队列
1. 
2. 
3. 

## 14.7 线程安全的集合
1. 
2. 
3. 

#### 14.7.1 高效的映射表、集合和队列
1. 
2. 
3. 

#### 14.7.2 写数组的拷贝
1. 
2. 
3. 

#### 14.7.3 较早的线程安全集合
1. 
2. 
3. 


## 14.8 Callable与Future
1. 
2. 
3. 

## 14.9 执行器
1. 
2. 
3. 

#### 14.9.1 线程池
1. 
2. 
3. 

#### 14.9.2 预定执行
1. 
2. 
3. 

#### 14.9.3 控制任务组
1. 
2. 
3. 

#### 14.9.4 Fork-Join框架
1. 
2. 
3. 


## 14.10 同步器
1. 
2. 
3. 

#### 14.10.1 信号量
1. 
2. 
3. 

#### 14.10.2 倒计时门栓
1. 
2. 
3. 

#### 14.10.3 障栅
1. 
2. 
3. 

#### 14.10.4 交换器
1. 
2. 
3. 

#### 14.10.5 同步队列
1. 
2. 
3. 

## 14.11 线程与Swing
1. 
2. 
3. 

#### 14.11.1 运行耗时的任务
1. 
2. 
3. 

#### 14.11.2 使用Swing工作线程
1. 
2. 
3. 

#### 14.11.3 单一线程规则
1. 
2. 
3. 


