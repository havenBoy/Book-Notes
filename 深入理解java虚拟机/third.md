# 第三章  垃圾回收器与内存分配策略
> 垃圾回收器在进行堆的回收前，需要确定这些对象那些是存活的，那些是已经死去的，这需要一定的算法：
   
## 1.引用计数法
   - 在对象中添加一个引用计数器，每当有一个地方引用时，计数器就加1，当引用失败时，计数器就减1，如果当计数器为0
的时候，说明这个对象是不再被使用的，但是这个算法无法解决对象互相引用的问题；
## 2.可达性分析
   - 把GC roots的对象作为起始点，从节点开始向下搜索，搜索的路径称为引用链，当一个对象与GC Roots没有任何的引用链
时，即不可达时，则这个对象是不可用的；
## 3.引用的分类
   - 1.强引用：显式的把一个对象赋值给另外一个对象；
   - 2.软引用：描述一些有但非必须的对象；
   -  3.弱引用：被其关联的对象只能生存在下一次垃圾回收发生之前；
	 - 4.虚引用：目的是在垃圾回收时可以收到系统的通知；
## 4.即使是对象不可达或者计数器为0，也不是意味着对象马上就被清除，而是必须要经过2次的标记，第一次的标记是对象是否有必要去执行finalize方法，如果对象已经
覆盖了finalize方法或者虚拟机已经调用了finalize方法，那么此对象没有必要执行finalize方法；但是如果对象有必要执行finalize方法，对象会放置在一个队列中，线程
优先级低的线程会去执行它，但是不会保证必须执行完，原因是担心造成死循环使得总的对象回收系统崩溃，在这之后会对队列中的对象进行第二次标记，意味着此时才被回收；
## 5.方法区的回收
  >  方法区也是有垃圾回收的，只不过是回收的效率比较低，主要回收废弃常量以及无用类，常量是否废弃容易，判断一个无用的类（必要不充分条件）：
   - 1.java堆中没有任何该类的实例对象 
   - 2.classLoader已被回收  
   - 3.无法在任何地方通过反射访问对象的方法；
## 6.回收算法描述：
  ### 1.标记-清除算法
    - 首先标记需要回收的对象，然后对标记的对象进行垃圾回收，缺点是回收后会有大片的不连续的内存出现，并且回收的效率不高；
  ### 2.复制算法
	  - 将内存分为2块，当一块的内存使用完后，对这块内存存活的对象复制到另外一块上，完毕后把之前的内存回收，缺点是：内存被降低到一半；
	  - 改进：并不需要把内存等分，而是2 8 原则，一般新生代回收效率较高，分为Eden区与2块survivor区，每次都是使用Eden与其中一块的survivor区；
  ### 3.标记-整理算法
	  - 针对老年代，先标记存活的对象，然后把存活的对象向一段移动，最后清理边界以外的内存
## 7.内存的分配以及回收策略
  - 1.大多情况下，会分配在新生代的Eden区，当没有多余的空间分配，发起一次minor Gc;
	 