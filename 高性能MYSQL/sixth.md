# 查询性能优化
> 深刻理解MySql是如何真正的执行查询
* 为何查询速度慢
  - 查询速度快意味着响应的时间变慢，如何把查询的操作分为多个子查询的集合，需要优化每一个子查询的查询速度，降低每个子查询的响应时间与执行次数
  - 执行过程：客户端 服务端  生成执行计划 执行 返回结果给客户端
  - 花费的时间体现：网络传输时间，CPU计算，生成计划，锁等待，内存操作，I/O操作
  - 优化查询的目的就是需要减少与消除不必要或者重复的操作
* 慢查询基础
  - 查询性能低下的原因一般在于访问的数据较多，需要在大量的数据中选择符合条件的数据，需要避免
  - 是否在扫描额外的记录，衡量查询开销的三个指标：
    * 响应时间
      - 服务时间+排队时间 = 响应时间
        * 服务时间指数据库处理查询实际花费的时间
        * 排队时间指由于在等待某些资源而没有真正的执行查询时间，一般为锁等待或者I/O
      - 需要有能力去衡量一个查询大概所需要的时间
    * 扫描的行数与访问类型
      - 关键字Explain使用  
      - 分析：在有无索引时，查询所扫描的行数，可以看出在有索引时的效率提高很多倍；
    * 返回的行数
      - 理想中查询时所扫描的行数与返回的行数一个是相同的，才说这个查询是比较高效的；
      - 上边所述只是理想性的，现实中一般需要扫描许多行才会有一行结果的生成；
* 结构查询重构的方式
  - 一个复杂查询还是若干个简单查询的选择
    * 因为对于MySQL客户端的连接与断开已经是轻量级的操作，MySQL的扫描与网络的带宽在当下时代也是比较令人比较满意的
    * 
  - 切分查询
    * 在实际中一般把大的delete操作拆分为多个子操作，因为大的语句带来的是锁住许多的数据，耗尽系统的资源，阻塞其他的子查询；
    * 尽量把对于空间的压力缓冲到时间的长度上，每次删除固定个大小的数据可以减少系统的吞吐量；
  - 分解关联查询
    * 可以把复杂查询转化为对每一个表进行单表查询，然后在程序中进行关联
    * 优点是：
      - 可以使得缓存的效率更高；
      - 查询分解后减少锁的竞争；
      - 在应用层的级联可以增加性能与扩展性；
      - 本身的查询效率也可以提高；
      - 减少冗余记录的查询；   
* 查询执行的基础
  * 一次查询的简单流程：
    - 1. 客户端发送一条请求到服务端
    - 2. 服务器首先检查查询缓存，是否可以命中缓存，否则进入下一步
    - 3. 服务器对sql解析，预处理，再由优化器生成对应的执行计划；
    - 4. 由生成的优化计划调用存储引擎的API执行查询；
    - 5. 返回结果给客户端；
  * 客户端与服务端的通信协议
    - 之间的通信协议是半双工的，意味着客户端与服务器的通信不能同时进行；
    - 查询的状态
      * 使用 show full processlist命令返回每一个命令当前的状态。各种状态解释如下：
        - sleep  线程等待客户端的发送新的请求
        - query  线程在执行查询或者在把查询结果发送给客户端过程
        - analyzing and statistics 在收集存储引擎的统计信息，并生成执行计划；
        - copying to tmp table[on disk]  在把统计的结果复制在临时表上，要么是group或者是union操作
        - sorting result  线程对结果集进行排序
        - sending data  可能在多个状态之间进行数据的传输或者是在向客户端进行传输数据】
* 查询缓存
  - 如果在查询缓存是打开的，会优先检查这个查询是否命中查询的缓存，是通过一个对于大小写敏感的哈希查找实现的，如果没有命中，会进行下一步的处理，如果命中缓存，会检查当前查询的权限，当权限没有问题的时候，就会直接从缓存中取出数据，而并不会进行sql语句的检查与执行计划；
  - 查询优化处理
    * 经过的步骤： 解析sql->预处理->优化sql执行计划；
    * 语法解析器与预处理 通过sql的关键字对sql语句进行解析，以致生成解析树，顺带权限的检验；
    * 查询优化器： 基于成本的优化器，会预测一个查询所需要的成本，会选择最小的一个
      - 使用last_query_cost值来判断成本  show status like 'last_query_cost'
      - 有很多的因素使得优化器使用错误的查询计划；
      - 优化策略分为静态优化和动态优化
        * 静态优化  通过简单的代数运算出查询成本，可认为是编译时优化，只做一次；
        * 动态优化  与查询的上下文有关，在每次查询都需要评估，认为是运行时优化；
        * 能够处理的优化类型：
          - 把外连接转换为内连接 会重写查询语句，调整关联的顺序
          - 通过等价变换来简化表达式
          - 优化聚合函数  count() max()
          - 预估转化为常数表达式
          - 覆盖索引扫描 直接从索引中取出需要的数据
          - 子查询优化  减少多个查询对于数据的重复扫描
          - 提前终止查询 如果查询已经满足查询需求，会提前终止查询，如limit关键字
          - 等值传播  
          - 列值in()比较  完全等同于多个or子句
    * 数据和索引的统计信息
      - 统计信息是有存储引擎实现，不同的存储引擎是有不同的统计信息
      - 存储引擎需要提供优化器对应的统计信息，方便优化器生成一个最优的执行计划
    * MYSQL如何执行关联查询
      - 在union语句中，会先把子查询的结果放在临时表中，然后是用临时表中的数据进行union查询；
      - 关联查询的策略：对于任何关联都会执行循环嵌套关联操作；
    * 执行计划
      - MYSQL不会生成字节码来完成查询，会生成一个指令树，由此通过存储引擎来完成指令树并返回结果数据集，是一棵左侧深度优先树
    * 关联查询优化器
      - 选择合适的关联顺序会让查询执行的成本尽可能低，使得进行了更少的循环嵌套和回溯操作
      - 如果由于搜索空间较大，会执行贪婪算法
    * 排序优化
      - 当不能使用索引排序时需要使用文件排序，在内存或者磁盘内进行
      - 排序缓冲区  会在这里进行快速排序  如果数据的大小大于这块内存，需要将数据分块，最后合并
  * 执行查询引擎
    * 根据执行计划来完成查询，执行的是一个数据结构而不是对应的字节码
    * 按照执行计划逐条指令进行执行，调用的是存储引擎底层的接口，重复执行各个操作直到完成数据的查询；
  * 返回结果给客户端
    * 结果集返回的客户端是逐步返回的过程，不是一次性返回
    * 服务器无需存储太多的结果，降低对于内存的消耗
    * 处理效率的提高，可以在第一时间得到响应
* MYSQL查询优化器的局限性
   * 略
* 优化特定类型的查询
  * 优化count()查询
  * 优化关联查询
  * 优化子查询
  * 优化group by和 distinct
  * 优化limit分页
  * 优化union查询
  * 静态查询分析
* 案例学习
  * 使用mysql构建队列
  * 计算俩点之间的距离
  * 使用用户自定义函数



     

