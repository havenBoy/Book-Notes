### JVM内存管理
> java中不会显式的调用分配内存的函数，因为分配内存与内存的销毁都由jvm自动完成，出现内存泄漏的几率较低，但有必要去了解jvm是如何管理内存的，这样在出现内存泄漏时能够迅速的定位到问题所在；

* 8.1 物理内存与虚拟内存
  - 物理内存指的是RAM（随机存储器），与之对应的是寄存器，用于存储计算单元执行指令的中间结果，决定一次计算可以使用的最大数值
  - 连接处理器与RAM是地址总线，宽度影响物理地址的索引范围，32位总线宽度可以有4Gb的内存空间
  - 在运行程序时需要向操作系统申请内存地址，进程直接是相互独立的，每个进程只能访问自己的内存空间，这里所谓的独立是指逻辑独立
  - 虚拟内存出现使得多个进程可以同时运行共享物理内存，还可以扩展地址空间
  - 一个进程在不活动的情况下，操作系统会把物理内存上的数据移到磁盘文件中，从而使得物理内存留给正在活动的程序使用，如果要重新唤醒一个很长时间没有使用的程序时，会把磁盘上的数据重新交给物理内存，这个交换需要尽可能的避免，系统会变得缓慢
* 8.2 内核空间和用户空间
  - 一般来说操作系统会把内存空间氛围内核空间和用户空间，程序只能使用用户空间
  - 内核空间指操作系统运行时所使用的用于程序调度，连接资源硬件的等程序逻辑
  - 空间的划分：为了保证操作系统的安全性与稳定性，用户程序是不能访问操作系统的内存空间，例如硬件的资源只能由操作系统来发起，当用户需要访问硬件资源时，需要系统调用，每一次的系统调用会存在2个空间的切换
  - 空间大小的划分：首先需要保证内核有足够的空间来运行
* 8.3 java中那些组件需要使用内存
  - java堆 用于存储java对象的内存区域  堆的大小在JVM启动时确定，由-Xms 与 -Xmx 分别代表最小与最大，堆的大小一旦确定，就不可再向操作系统再次申请，同时空闲时也不可再次利用 
  - 线程  JVM实际运行的实体   如果处理的线程数大于当前系统的处理器数量，那么效率会比较低
  - 类与类加载器  称为永久代  JVM会按需加载的，不会把一个jar包的所有类全部加载
  - NIO
    * 引入一种基于通道与缓冲区来执行I/O的新方式，分配内存时本机内存而不是java堆内存，每次分配都会系统调用
    * 如果产生的数据只是在操作系统的内核中，那么不需要把数据复制在Java内存中，效率也较高
  - JNI 
    * 使得本机程序可以调用java方法，也就是native memory，实际上本身的java应用会调用类库功能 例如文件操作，网络I/O
    * 会增加java运行时本机内存占用
* 8.4 JVM内存结构
  - PC寄存器 ： 保存当前正常执行程序的内存地址，对于native方法没有必须记录记录执行的指针位置
  - java栈 ： 每创建一个线程就会创建一个java栈，栈中会有多个栈帧，栈帧与每个方法关联起来，包括参数，以及方法返回值信息
  - 堆： 存储java对象，是被所有java线程共享的，所以需要注意到同步的问题
  - 方法区 : 存储类结构信息的地方，
  - 运行时常量池： 
  - 本地方法栈: 为JVM 运行Native方法准备的空间，许多的Native方法都是由C实现的
* JVM内存分配策略
  - 8.5.1 通常的内存分配策略
    * 静态内存分配  程序编译时确定每个数据在运行时的存储空间需求
    * 栈内存分配  动态分配策略 按照先进后出的原则进行分配内存
    * 堆内存分配 在代码真正运行到响应的代码时才会知道空间的大小  运行的效率太差
  - 8.5.2 java内存分配详解
    * 栈
      - 栈的分配是和线程绑定在一起的，在创建一个线程时，会线程创建一个java栈，线程的调用和返回分别对应java栈的压栈和出栈
      - 栈中主要存放基本的数据类型，对象的引用，存取速度比堆快，栈的数据可以共享，缺点是存在栈的数据大小和生存期是固定的，缺乏了灵活
    * 堆
      - 每一个java应用都唯一对应一个JVM实例，每一个实例对应一个堆，应用程序在运行中所创建的所有类的实例或者数组都放在堆中，由应用的所有线程共享
      - java中分配堆内存是自动初始化的，堆中存放的是这个对象本身，而在堆栈的分配的内存是一个指向这个堆对象的指针
      - java堆是一个运行时的数据区，不需要显示的代码释放，是由垃圾回收负责的，可以动态的分配内存的大小，缺点是存取的速度较慢
    * 堆和栈通俗的比较 ： 堆是用来存放对象的，栈是用来执行程序的
* JVM内存回收策略
  - 8.6.1 静态内存分配
    * 在编译时就能够确定需要内存空间，当程序被加载时系统一次性把内存分配给它，直到程序结束
  - 8.6.2 动态内存分配与回收
     
  - 8.6.3 如何检测垃圾
    * 
    
  - 8.6.4 基于分代的垃圾回收策略
    * 把对象按照寿命的长短来分组，分为老年代与年轻代，对象新创建在年轻代，对象经过几次回收以后如果任然存活，就分在老年代，年老代不会像年轻代回收那么频繁，减少了扫描的对象，提高垃圾回收的效率
    * JVM把整个堆分为Young Old Perm区
      - Young区分为Eden区与2个survior区，所有创建新的对象在Eden区，当Eden区域发生MinorGC后任然存活的对象存放在任意的一个survors区，并且保证其中的一个存活区是空的
      - Old区域存放的是Young区域的存活区出发minorGC中任然存活的对象，如果Old区域也满了，就会触发一个FullGC回收整个堆内存
      - Perm区主要存放的是类的class对象，如果一个类被频繁的加载，会导致Perm区域满，在发生FullGC时，Perm区域也会被垃圾回收的
    * GC收集分类
      - Servial Collector 
        * 是默认的JVm在client模式下GC方式
      - Parallel Collector
        * 
      - CMS Colletctor
        * 
* 8.7 内存问题分析
  - 8.7.1 GC日志分析
    * 在JVm启动的时候加一些参数，可以在内存发生溢出的时候记录下当时的情况
  - 8.7.2 堆快照文件分析
    * 通过命令jmap-dump:format=b,file=[filename][pid]来记录下堆的内存快照，然后利用第三方工具来分析这个Heap的对象关联情况
  - 8.7.3 JVM Crash 日志分析
    * JVM 有时间可能因为一些原因而直接垮掉，JVM本身的BUg可能导致JVM异常而退出
    * 在退出的时候会产生一个日志文件