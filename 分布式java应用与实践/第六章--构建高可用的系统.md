第六章--构建高可用的系统
  * 避免系统出现单点  一般的处理办法是把系统部署在多台机器上，其中每一台机器都提供相同的功能，这种系统环境称为集群。在集群的环境下，除了使得系统做到可伸缩，同时也要注意到2个问题，
    * 1.如何使得访问能够均衡的作用在这些服务器上；
    * 2.当其中的一个服务器出现问题时，使得访问不在作用在这个服务器上；
  * 解决上述的问题，用到负载均衡的技术，分为硬件负载均衡和软件负载均衡，使得有一台服务器是处于预备的状态的，当出现问题时，会自动替补；
  * 如何选择实际处理机器，实际是IP地址的转发：
    * 1.随机选择，对地址列表中随机选择一台，最为简单，性能也是最高的；
    * 2.hash选择，对资源的地址做hash；
    * 3.顺序选择，性能相当于随机选择，实际使用的案例较多；
    * 4.权重选择， 权重分为静态与动态，
      - 前者是在集群中已经配置好各个机器的权重，更好的利用机器的性能；
      - 后者是负载均衡设备或者根据软件处理业务连接数来动态分配，更好发挥业务处理机器的性能
    * 5.负载选择；
      - 根据实际业务处理机器的负载选择，选择负载相对较低的机器来处理，尽可能的是的各个机器的负载是均衡的；
    * 6.链接选择；
      - 根据实际的业务处理机连接数来决定，连接数相对较少的来处理业务；
  * 响应返回方式：
    * 1.通过负载均衡返回，返回的信息原路返回；
    * 2.响应直接返回请求方，这样就将请求包和响应包分开处理，从而缓解负载均衡器的压力
  * 热备
    * 热备的情况下真正的对外提供服务的机器只有一台，其他机器通过心跳机制检测对外服务器的状态，当出现问题时，备用机会进行接管；
    * 对于多个机房可以避免单个机房的灾难性事故，但出现了新的问题：
      - 跨机房的状态同步 包括数据库与内存数据的同步，会有网络延迟的问题
      - 如果是单master多salve模式，需要自行执行基于中间件方式实现
      - 如果是多master有多个写入点，采取两阶段提交，三阶段提交；
    * 两阶段提交保持唯一性
      - 为了保证多master数据的一致性 
        * 1.开启事务 
        * 2.通知每个master执行操作，
        * 3 锁定操作的资源
        * 4 如果有一个master通知不能执行时，需要其他的master执行回滚操作
        * 通知所有的master完成操作
    * 三阶段提交保证数据的唯一性
      - 为了避免在通知所有master提交时，其中一个master crash不一致时，会出现三阶段提交；
      - 三阶段是在两阶段的基础上增加preCommit的过程，在master接受到preCommit时，不会立即提交，而是直到收到commit或者超过一定时间才能完成操作
    * 基于paxos保持一致性
      *    ++++

  * 提高应用自身的可用性
    - 尽可能避免故障
      * 明确使用场景
        - 原基础上加上很多的复用导致一些不必要的实现导致故障
        - 在设计时没有从使用的场景去考虑，而是从技术的角度，设计了许多不必要的功能
      * 设计可容错的系统
        - fail fast 原则  如果在系统启动的时候缓存加载失败需要直接退出jvm 避免启动后的不可用
        - 保证接口与对象设计的严谨 接口是按照接口文档进行开发的，如果不是按照文档来调用会出现未知的错误
  * 设计具备自我保护的系统
    * 避免系统在依赖第三方考虑问题的连锁反应导致的宕机，所以保持对第三方的依赖位置保持怀疑态度，使得在第三方出现问题时对系统本身的影响不大
  * 限制使用资源
    * 限制内存的使用
      - 注意对jvm的使用限制，避免频繁的full GC或者内存溢出的现象
    * 限制文件的使用
      - 日志文件在所有线程争抢写入文件的锁，会导致写入速度变慢，最后应用崩溃；需要控制单个日志的大小，另外是控制文件写入的频率
    * 限制网络的使用
      - 连接资源，典型的就是客户端使用连接池方式来避免对服务器的连接数量过多，服务端自身也需要控制自身过多的连接
      - sendBuffer区资源 在向服务器发送流时，会先放在sendBuffer区，本身是有限的；控制是当到达一定的阈值时会拒绝发送，或是根据内存的消耗状态延迟应用的发送速度
    * 限制线程的使用
      - 多线程实现需要消耗物理内存与jvm内存，内存较多会花费在CPU切换
    * 从其他角度避免故障
      - 需要对使用到的框架以及使用的java类库熟悉
  * 及时发现故障
    * 发生故障的原因太多，基本不能再非运行阶段做到对故障的避免，要根据对发生故障时的日志记录对故障的原因做出合理的分析
  * 日志记录与分析系统
    * 不能因为记录数据而导致应用的问题
    * 快速记录与分析所有应用的数据
* 及时处理故障
  * 1. 自动修复  学习总结各类故障的处理措施，做到对将来故障智能化的处理
  * 2. 执行风险点应对措施 当属于之前判断的系统风险点是，直接执行风险点对应的措施，比较快速
  * 3. 全局资源调整  当故障是由某集群的压力过大时，可以全局的资源调整，如流量的分配，路由策略调整全局资源的分配
  * 4. 功能降级  故障出现后没有办法及时修复所以要把系统的某些功能关闭，以保证核心功能的可用
  * 5. 降低对资源的使用量  如：数据库最大连接数的降低 缩短数据库连接的等待时间 
  * 访问量及数据量不断上涨的应对策略
    * 拆分系统及水平伸缩 通常按照系统的功能拆分
    * 数据库表中数据越来越多 读写越来越慢 ，一般是拆分表  读写分离
    * 


    
        