### 深入理解java虚拟机读书笔记

##### 第一章：走进java（略）

##### 第二章：运行时数据区域

![图片](https://github.com/havenBoy/notes/raw/master/img/1.png)

**对图中的各个区域的解释**
**1**.程序计数器，一个较小的内存，是当前线程执行字节码的指示器，并取到下一条执行的字节码指令，<br>
      同时线程之间的程序计数器是相互不影响的，称为线程私有的内存；如果执行的是一个native方法，程序计数器为空<br>
	  
2.java虚拟机栈 
   java虚拟机栈同样是线程私有的，方法在执行的时候，都会创建一个栈帧，用于存储局部变量，方法出口，从一个栈帧在虚拟机栈中
的入栈和出栈，对应人们经常说的栈；如果线程申请的栈深度大于虚拟机所允许的深度，抛出Stack Overflow异常，但如果在扩展时育无法
申请到足够的内存，那么抛出out of memoryError异常；
3.本地方法栈
   虚拟机栈是为字节码服务的，而本地方法栈则为虚拟机所用到的native方法服务；
4.java堆
   java堆是java虚拟机所管理的内存中最大的一块，是被所有的线程共享的，此区域是存放对象的实例，几乎所有的对象都是在这里
来分配内存的，意味着有些变量是在栈中分配内存的；它是垃圾收集管理的主要区域，可以分为新生代和老年代，再细致可以分为eden,
From Survivor空间，To Survivor空间;同时java堆可以位于物理不连续的内存空间中，如果堆中没有多余的内存分配，抛出out of memoryError异常；
5.方法区
    方法区是每个线程共享的内存，用于存储类信息，常量等数据，称为“永久代”；但并不是说这个区域不进行垃圾回收，只是条件比较苛刻，
，如果此区域没有办法内存分配时，抛出out of memoryError异常；

1.对象的创建
    当虚拟机遇到new的指令时，首先会检测这个指令的参数是否能在常量池中定位到一个类的引用，检测这个符号是否已被加载，解析或者初始化
过，如果没有那么执行类的加载过程，加载过后，虚拟机会为新生对象分配内存，分配内存有2中方法：指针碰撞与空闲列表，同时需要考虑
线程安全的问题，也有2中方法：1.在分配的操作上进行同步的处理 2.每个线程在java堆中预先分配一块小内存，在每个线程分配内存时，在属于自己
的内存上进行分配，当自己的小内存（TLB）用完时，才会进行同步的操作；在分配操作完毕时，需要对分配的内存进行初始化的操作，之后会对对象的元数据，
对象的哈希值，已经分代的信息进行赋值，这些信息放在对象的头中，最后这个对象会根据代码的指令进行对象的构造，完成了对象的创建；
2.对象的内存布局
    对象头，实例数据以及填充信息，对象头中包括：自身运行时数据，哈希码值，GC分代年龄，锁标志的信息，对象头的另外一部分是类型指针，
    
	  
	  

