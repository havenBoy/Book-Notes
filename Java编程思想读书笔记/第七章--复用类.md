# 讲解组合和继承这2种代码复用机制
**7.1 组合语法**<br>
*把对象的引用放在新的类中即可，这些引用可以在代码的下列位置进行<br>
1.定义对象的地方<br>
2.类的构造器中<br>
3.使用这些对象时，惰性初始化<br>
4.实例初始化<br>
**7.2 继承的语法**<br>
*super表示超类的意思，可以在子类中直接调用父类的方法；<br>
*正确的初始化基类，以及初始化基类的正确顺序，是先创建基类然后到子类，向外扩散的；<br>
*如果有基类有带参数的构造器，那么就要在子类中使用super来显示调用父类的带参数的构造器；<br>
**7.3 代理**<br>
*把一个成员对象置于所要构造的对象中，与此同时，把对象的所有的方法暴露出来，这样就致实现了对象的调用，实现了对象的复用；<br>
**7.4. 组合使用组合和继承**<br>
**7.4.1 确保内存能够被正常的清理**<br>
*因为不知道垃圾回收器是在什么时候调用，或者是否调用，因此如果想执行某个清理的动作，就必须显示的编写一个特殊方法，并且将清理的动作放在finally中，以防异常的发生，并知道清理方法与成员对象的调用的顺序，清理的动作与生成的顺序刚好相反，最好依赖于自己写的清理的方法，注意不要使用finalize；<br>
**7.4.2 名称的屏蔽**<br>
*基类中有多个已被重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽基类中的版本；<br>
**7.5 在组合和继承之间的选择**<br>
* 理解在什么情况下使用那种，组合是显示的放置子对象，而继承是隐式的放置，组合在最好是设置子对象属性为private；<br>
**7.6 Protect 关键字**<br>
* 这个关键字提供了包内的访问权，提供了子类访问父类变量成员变量的方法；<br>
**7.7 向上转型**<br>
*把子类引用转换为父类引用的动作，称为向上转型；<br>
*使用组合和继承的场景，判断是否需要从新类向基类中进行向上转型，如果是必须的话，则采用继承，否则应该尽量避免使用；<br>
**7.8 final关键字（不可改变的东西）**<br>
*作用于数据时：表示数据是不可改变的，如果加上static修饰的时候，则是不可修改的一块固定的存储空间；<br>
，当对对象引用加以final修饰时，表示引用是不可修改的，无法把这个引用再次指向另外的一个对象，但是对象的本身是可以修改的，当参数列表中有参数被final修饰时，则表示参数可以读，但是不可以修改参数；<br>
*当作用于方法时：首先表示此方法不可以被覆盖，第二是因为效率，当编译器方法发现是final时，那么就会跳过像之前的参数入栈，跳到方法的指向的地方，然后清理栈中的参数，最后处理返回的值的步骤，而是以方法中的实际代码代替方法调用，从而降低调用的开销，但是考虑到实际的方法体本身是很大的，那么代码会膨胀，那么并不会带来性能的提升，所以这种考虑就会被逐渐淡化，导致了以方法为不可覆盖的考虑时，会以final的修饰，类中所有private的方法是默认不可覆盖的；<br>
*作用于类时：表示此类不允许继承，处于安全的考虑，不想有其子类；<br>
**7.9 初始化以及类的加载**<br>
*static对象或者数据会在加载时依次按照声明的顺序来创建，且只会被初始化一次；<br>
*加载的顺序：首先找出类的编译代码，首先会注意到此类是否有基类，基类依次的加载，然后是导出类的加载，必要的类加载完毕以后，对象可以创建，对象所有的基本属性会初始化，，之后基类的构造器调用，实例变量会依次初始化，最后是构造器的其他部分会被执行；<br>
**总结：**
*在设计时，一般会优先使用组合，只有当需要向上转型时，才会考虑使用继承，组合具有较强的灵活；<br>