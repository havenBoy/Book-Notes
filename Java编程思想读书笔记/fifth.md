### 初始化与垃圾回收是设计安全的2个问题

* 5.1 使用构造器确保对象的初始化
  - 考虑到初始化期间要自动的调用构造器，所以构造器采用和类相同的名称；
  - 不接受任何参数的构造器称为默认构造器，即无参构造器，当然也可以定义一个接受参数的构造器，这样就不允许以其他形式来创建对象，从而减少错误；
  - 构造器没有返回值，与返回空（void）是不同的；
* 5.2 方法重载
  - 构造器是强制重载方法名的另一个原因，同时方法名也是适用的
  - 区分重载方法：每个重载的方法都有一个独一无二的的参数列表，同时参数的顺序也是可以的，但是不提倡这么做
  - 不能以返回值的方式来区分重载的方法
* 5.3 默认构造器
  - 如果没有编译器会自动的创建一个，如果自己已经定义了一个属于自己的构造器，然后调用无参的默认构造器，那么就会报错
* 5.4 this关键字
  - 2个对象同时调用一个方法，会传递一个所操作对象的引用，this关键字只能在方法的内部使用，表示调用方法的对象的引用，同一类的其他的方法的调用不用this即可；
  - 构造器中构造器的调用：this只能调用一个构造器，不能调用2个，同时位置在最起始处，否则会报错；
  - 除了在构造器中的构造器的调用，其他方法中不能调用任何构造器
  - static 含义：static就是没有this的方法，static方法中不能调用非静态方法，通过类名本身来调用静态方法
* 5.5 垃圾的回收
  - java有垃圾回收器负责对于无用对象的对资源的占用，对于不是由new出来的一块内存区域的垃圾回收，则允许类中定义一个finalize()的方法，在垃圾回收的之前，会先调用这个方法，做一些比较重要的清理工作，但不应该作为通用的垃圾回收的方法。
  - 1.对象可能不被垃圾回收
  - 2.垃圾回收不等于析构
  - 3.垃圾的回收只与内存的大小有关，内存不够才会试着去垃圾回收，垃圾回收的本身也是需要资源和空间的；
  - 4.finalize方法作用是由于分配内存时，采用了本地方法，而不是java通常的方法，释放的通常是本地方法请求到的内存；
  - 5.并没有定义一个方法进行清理的操作，也不能保证清理的一定执行；
  - 6.finalize对终结条件的验证；
  - 7.垃圾回收器的工作原理:引用计数的原理和复制收集的理解；
* 5.6 成员的初始化
  - 1.基本类型的初始化默认值，以及对象的默认值为null，同时对于成员的使用遵照先定义后使用的原则；
* 5.7 构造器的初始化
* 5.8 数组的初始化
* 5.9 枚举类型 枚举类型的使用
  - 包括一些具有的实用的方法，包括ordinal values 以及和switch的搭配使用


